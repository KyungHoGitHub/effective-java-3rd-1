# 아이템 18. 상속보다는 컴포지션을 사용하라.

### 구현 상속의 좋은 케이스 나쁜 케이스
 - 상속이 괜찮은 경우
   - 상위 클래스와 하위 클래스를 한명의 프로그래머가 통제하는 패키지인 경우 ( 괜찮을 가능성이 높다 )
   - 확장할 목적으로 설계되었고 문서화도 잘 된 클래스인 경우 <span style="color: orange">[ 아이템 19 ]</span>
 - 상속이 안좋은 경우
   - 서로 다른 패키지에 있는 구체 클래스가 다른 구체 클래스를 상속할 때 발생

### 구현 상속의 문제점
 - 상속은 캡슐화를 깨뜨린다. ( 상위 클래스의 변경이 하위 클래스의 동작에 문제를 발생시킬 수 있다. )
 - 문제 발생 시 상위 클래스의 메서드 동작을 수정하는것은 어렵다.
 - 하위 클래스에서 접근할 수 없는 private 필드, 메서드를 사용해야 하는 순간이 온다면 구현이 불가능해진다.
 - 하위 클래스에서 메서드를 재정의하여 당장의 문제를 해결해도 상위 클래스의 변경이 발생하면 문제가 발생할 수 있다.
 - 하위 클래스에서 새로운 메서드를 추가하는 방식은 상위 클래스에서 동일한 이름, 다른 반환 타입을 가지는 메서드를 만든다면 컴파일도 안되는 사태가 발생할 수 있다.
 - 상위 클래스에서 작성된 메서드의 규약을 따르지 못할 가능성이 큼  
 
### 컴포지션 추가 설명
 - 다른 인스턴스를 감싸고( wrap )하고 있다는 뜻에서 래퍼 클래스라 함
 - 계측 기능을 덧 씌운다는 뜻에서 데코레이터 패턴( decorator pattern ) 이라고 함
 - 컴포지션과 전달의 조합은 넓은 의미로 위임( delegation )이라고 함 

### 컴포지션의 단점
 - 콜백(callback) 프레임워크와는 어울리지 않음
   - 자기 자신의 참조를 다른 객체에 넘겨서 호출하도록 한다.
   - 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르니 자신의 참조를 넘김
   - 콜백 시 래퍼가 아닌 내부 객체를 호출하게 됨. 이를 self 문제라고 한다.
 - 전달 메서드가 성능에 주는 영향이나 래퍼 객체가 메모리 사용량에 주는 영향을 걱정하는 사람도 있지만 실제 영향이 없다고 확인되었다!
 - 전달 클래스를 작성하는 과정이 지루하지만 구현만 한다면 다음에 재사용하는 것이 아주 간편하다 

### 상속을 사용해야 할 때
 - 클래스를 작성할 때 이것이 상속받을 상위 클래스에 어울리는 상황에서만 진행해야 한다.
   - 신규 클래스 B는 A를 상속받아야 하는 경우 B는 A인가? 를 자문하고 확실히 B는 A일때 진행한다.
     - 만약 아니라면 컴포지션이다!
   - 커피 > 라떼는 상속이다!
   - 커피 > 홍차는 컴포지션이다!

### 마무리
 - java의 Stack과 Vector, Properties와 Hashtable는 잘못된 케이스이다.
   - 이러한 케이스는 컴포지션을 사용해야 했다!
   - Stack은 LIFO( last in first out )이지만 Vector는 그저 확장 가능한 배열임으로 Stack은 Vector를 대변할 수 없다...!
   - Properties getProperty method를 호출하지 않고 get method ( Hashtable )를 직접 호출하는것은 상위 클래스의 불변식을 해칠 수 있다.
 - 무분별한 상속은 캡슐화를 깨트릴 수 있다. 구현 상속에서 정말 상속이 옳은지 아래 내용에 대해서 검토가 필요하다.
   - 확장하려는 클래스의 API에 아무런 결함이 없는가?
   - 결함이 있지만 다른 API에 전파되어도 괜찮은가? ( 당연히 괜찮을리 없다. )
 


