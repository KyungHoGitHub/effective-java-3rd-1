# 아이템 8. finalizer와 cleaner 사용을 피하라

* 자바는 두 가지 객체 소멸자를 제공한다.

1. finalizer  
finalize 메서드는 최상위 Object 클래스에 포함된 메서드이다. 그래서 어느 클래스던지 finalize 메서드를 재정의 할 수 있다.
finalize 메서드를 재정의(Overriding)하면 해당 객체가 가비지 컬렉션 대상이 되었을 때 finalize메서드가 호출된다. 단, 즉시 호출을 보장받을 수는 없다.
즉시 호출이 보장되지 않기 때문에 한정적 자원 해제시 해제하는 작업을 finalizer로 구현하면 안된다. 이런 경우 try-with-resource 또는 try-finally를 이용해 구현해야 한다.
finalize 메서드는 자바9부터 deprecated 되었고 이에 대한 대안으로 자바에서는 Cleaner를 지원하게 되었다.

> 더 이상 사용되지 않습니다. 종료 메커니즘은 본질적으로 문제가 있습니다.  
> 종료는 성능 문제, 교착 상태 및 정지로 이어질 수 있습니다.  
> 종료자의 오류로 인해 리소스 누수가 발생할 수 있습니다. 더 이상 필요하지 않은 경우 종료를 취소할 방법이 없습니다.   
> finalize 다른 개체의 메서드 호출 간에는 순서가 지정되지 않습니다. 또한 확정 시점에 대한 보장도 없습니다.

2. cleaner  
자바 9부터 finalizer 대신 새로운 소멸자인 java.lang.ref 패키지에 포함된 cleaner를 대안으로 제공한다.   
cleaner는 API로 제공했던 finalizer처럼 재정의(Overriding)하는 것과 달리 구성을 통해 cleaner를 사용해야 한다.  
하지만, cleaner 역시 예측할 수 없고, 느리고, 일반적으로 불필요하다.

## 사용하면 안되는 이유
1. 수행 시점 뿐 아니라 수행된다는 여부조차 보장이 없다.
> finalizer와 cleaner는 호출된 후 언제 실행될 지 알 수 없다.  
> 즉, 제때 실행되어야 하는 작업을 절대 할 수 없다.  
> 심지어 실행이 되지 않을 수도 있다.  

2. 동작 중 발생한 예외가 무시된다.
> finalizer는 동작 중 발생할 예외를 무시하며, 처리할 작업이 남았더라도 그 순간 종료된다.  
> 잡지 못한 예외 떄문에 해당 객체는 훼손될 수 있고, 다른 스레드가 이 훼손된 객체에 접근하게 될 수 있다.  
> cleaner는 자신의 스레드를 통제하기 때문에 위의 문제는 발생하지 않는다.  

3. 성능 이슈
> GC 과정에서 수행하기 때문에 성능 저하가 발생할 수 있다.  
> JVM 튜닝의 많은 부분이 GC로 인한 stop-the-world를 줄이기 위함일텐데, GC 과정 중에 finalize() 메서드의 할일이 늘어나면 전체적인 성능 저하가 발생할 수 있다.

4. 보안 이슈
> 생성자나 직렬화 과정에서 예외가 발생하면, 생성되다만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다.

## 어디에 사용되는가?
안전망, 네이티브 라이브러리를 사용하는 경우를 제외하고는 사용하지마라

